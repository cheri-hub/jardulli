# Como Funciona a Integra√ß√£o Gemini - An√°lise do Backend de Exemplo

## üìö Vis√£o Geral

Este documento explica **detalhadamente** como o backend de exemplo (`agrosinergia_responde_backend`) implementa a integra√ß√£o com **Google Gemini** para criar um sistema de **RAG (Retrieval-Augmented Generation)** - perguntas e respostas baseadas em documentos.

---

## üéØ O Que o Sistema Faz

### Objetivo Principal
Permitir que usu√°rios fa√ßam perguntas e obtenham respostas **baseadas exclusivamente** em documentos (PDFs, TXTs, MDs) armazenados no servidor, usando o Google Gemini para processar e gerar as respostas.

### Fluxo Simplificado
```
1. Documentos ficam na pasta docs/
2. Sistema faz upload dos documentos para Gemini File API
3. Usu√°rio faz pergunta via POST /perguntar-gemini
4. Sistema envia documentos + pergunta para Gemini
5. Gemini analisa documentos e responde
6. Resposta formatada retorna para o usu√°rio
```

---

## üèóÔ∏è Arquitetura da Solu√ß√£o Gemini

### Estrutura de Arquivos

```
agrosinergia_responde_backend/
‚îÇ
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ perguntar-gemini.ts    ‚Üê Rota que recebe perguntas
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ gemini.ts              ‚Üê L√≥gica de integra√ß√£o com Gemini
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ stores/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ threadsStore.ts        ‚Üê Gerencia hist√≥rico de conversas
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ config.ts                  ‚Üê Configura√ß√µes e paths
‚îÇ
‚îú‚îÄ‚îÄ docs/                          ‚Üê Documentos (PDF, TXT, MD)
‚îú‚îÄ‚îÄ file_cache.json                ‚Üê Cache de arquivos j√° enviados
‚îú‚îÄ‚îÄ threads.json                   ‚Üê Hist√≥rico de threads locais
‚îî‚îÄ‚îÄ .env                           ‚Üê Vari√°veis de ambiente
```

---

## üîß Componente 1: Configura√ß√£o (`config.ts`)

### Vari√°veis de Ambiente

```typescript
export const GEMINI_API_KEY = process.env.GEMINI_API_KEY || "";
export const GEMINI_MODEL = process.env.GEMINI_MODEL || "gemini-2.5-pro";
```

**O que configurar no `.env`**:
```env
GEMINI_API_KEY=AIza...                    # API key do Google AI Studio
GEMINI_MODEL=gemini-2.5-flash             # Ou gemini-2.5-pro
```

### Paths Importantes

```typescript
export const DOCS_DIR = path.join(ROOT_DIR, "docs");
export const GEMINI_CACHE_FILE = path.join(ROOT_DIR, ".gemini_cache.json");
export const THREADS_FILE = path.join(ROOT_DIR, "threads.json");
```

- **`docs/`**: Onde voc√™ coloca seus PDFs, TXTs, MDs
- **`file_cache.json`**: Evita reenviar arquivos j√° carregados
- **`threads.json`**: Hist√≥rico de conversas (opcional para Gemini)

---

## üöÄ Componente 2: Service Gemini (`services/gemini.ts`)

Este √© o **cora√ß√£o** da integra√ß√£o. Vamos analisar passo a passo.

### 2.1 Inicializa√ß√£o do Cliente

```typescript
import { createPartFromUri, GoogleGenAI } from "@google/genai";

const GEMINI_API_KEY = process.env.GEMINI_API_KEY || "";
const ai = new GoogleGenAI({ apiKey: GEMINI_API_KEY });
```

**O que acontece**:
- Importa SDK oficial do Gemini (`@google/genai` vers√£o 1.13.0)
- Cria inst√¢ncia do cliente com a API key
- Este cliente ser√° usado para upload e gera√ß√£o de conte√∫do

---

### 2.2 Sistema de Cache de Arquivos

#### Por que Cache?
Evitar **reupload** de arquivos que j√° foram enviados ao Gemini. Uploads s√£o lentos e consomem quota.

#### Estrutura do Cache (`file_cache.json`)

```json
{
  "a3f5e9b2c1d4...": {
    "name": "files/abc123xyz",
    "uri": "https://generativelanguage.googleapis.com/v1beta/files/abc123xyz",
    "mimeType": "application/pdf",
    "displayName": "manual.pdf",
    "uploadedAt": "2025-10-17T10:30:00.000Z"
  },
  "d7c2b8a4f6e1...": {
    "name": "files/def456uvw",
    "uri": "https://generativelanguage.googleapis.com/v1beta/files/def456uvw",
    "mimeType": "text/plain",
    "displayName": "regras.txt",
    "uploadedAt": "2025-10-17T11:45:00.000Z"
  }
}
```

**Chave**: Hash SHA256 do conte√∫do do arquivo  
**Valor**: Metadados do arquivo no Gemini (name, uri, mimeType, etc)

#### Fun√ß√µes de Cache

```typescript
function loadFileCache(): FileCache {
  try {
    return JSON.parse(fs.readFileSync(FILE_CACHE_PATH, "utf8"));
  } catch {
    return {}; // Arquivo n√£o existe ou JSON inv√°lido
  }
}

function saveFileCache(c: FileCache) {
  fs.writeFileSync(FILE_CACHE_PATH, JSON.stringify(c, null, 2), "utf8");
}
```

#### Fun√ß√£o de Hash

```typescript
function sha256File(absPath: string): string {
  const buf = fs.readFileSync(absPath);
  return crypto.createHash("sha256").update(buf).digest("hex");
}
```

**Por que SHA256?**  
Se voc√™ modificar 1 byte no arquivo, o hash muda completamente ‚Üí sistema detecta que precisa fazer novo upload.

---

### 2.3 Upload de Arquivos com Cache

Esta √© a **fun√ß√£o mais importante**:

```typescript
async function uploadLocalFileWithCache(absPath: string) {
  // 1. Calcula hash do arquivo
  const hash = sha256File(absPath);
  const cache = loadFileCache();

  // 2. Verifica se j√° existe no cache
  if (cache[hash]) {
    console.log(`‚úÖ Cache HIT: ${path.basename(absPath)}`);
    return cache[hash]; // Retorna dados salvos (n√£o reenvia!)
  }

  console.log(`üì§ Uploading: ${path.basename(absPath)}`);

  // 3. Determina MIME type
  const ext = path.extname(absPath);
  const mimeType = mimeFromExt(ext); // .pdf ‚Üí application/pdf
  const displayName = path.basename(absPath);

  // 4. L√™ arquivo como buffer e cria Blob
  const buf = fs.readFileSync(absPath);
  const blob = new Blob([buf], { type: mimeType });

  // 5. FAZ UPLOAD para Gemini File API
  const uploaded = await ai.files.upload({
    file: blob,
    config: { displayName },
  });

  // 6. Valida√ß√£o: garante que recebeu 'name'
  if (!uploaded?.name || typeof uploaded.name !== "string") {
    throw new Error(`Upload n√£o retornou 'name' v√°lido para "${displayName}".`);
  }

  // 7. POLLING: aguarda processamento do arquivo
  let getFile = await ai.files.get({ name: uploaded.name });
  while (getFile.state === "PROCESSING") {
    console.log(`‚è≥ Processing: ${displayName}...`);
    await new Promise((r) => setTimeout(r, 2000)); // Aguarda 2 segundos
    getFile = await ai.files.get({ name: uploaded.name });
  }

  // 8. Verifica se processamento foi bem-sucedido
  if (getFile.state === "FAILED") {
    throw new Error(`Processamento de arquivo falhou: ${displayName}`);
  }

  // 9. Valida√ß√£o final
  if (!getFile?.name || !getFile?.uri) {
    throw new Error(
      `Arquivo "${displayName}" processado, mas sem 'name' ou 'uri' retornados.`
    );
  }

  // 10. Salva no cache para reutilizar depois
  const entry = {
    name: getFile.name,
    uri: getFile.uri,
    mimeType,
    displayName,
    uploadedAt: new Date().toISOString(),
  };

  cache[hash] = entry;
  saveFileCache(cache);

  console.log(`‚úÖ Cached: ${displayName}`);
  return entry;
}
```

#### Estados do Arquivo no Gemini

```
PROCESSING ‚Üí Gemini est√° processando (pode levar segundos/minutos)
ACTIVE     ‚Üí Pronto para uso
FAILED     ‚Üí Erro no processamento
```

#### Por que Polling?

Gemini File API √© **ass√≠ncrona**. Quando voc√™ faz upload, o arquivo n√£o est√° imediatamente dispon√≠vel. Voc√™ precisa **verificar o estado** at√© ficar `ACTIVE`.

---

### 2.4 Coleta de Documentos

```typescript
function listDocs(exts = [".pdf", ".txt", ".md"]) {
  if (!fs.existsSync(DOCS_DIR)) return [];
  return fs
    .readdirSync(DOCS_DIR)
    .map((f) => path.join(DOCS_DIR, f))
    .filter(
      (full) =>
        fs.statSync(full).isFile() &&
        exts.includes(path.extname(full).toLowerCase())
    );
}
```

**O que faz**: Lista todos os arquivos `.pdf`, `.txt`, `.md` da pasta `docs/`.

```typescript
async function collectDocParts() {
  const files = listDocs();
  const parts: any[] = [];

  for (const abs of files) {
    const meta = await uploadLocalFileWithCache(abs);

    // Cria "part" que o Gemini entende
    if (typeof meta.uri === "string" && typeof meta.mimeType === "string") {
      parts.push(createPartFromUri(meta.uri, meta.mimeType));
    }
  }
  return parts;
}
```

**O que √© `createPartFromUri`?**  
√â uma fun√ß√£o helper do SDK que cria um objeto no formato que o Gemini espera:

```typescript
// Internamente cria algo assim:
{
  fileData: {
    fileUri: "https://generativelanguage.googleapis.com/.../files/abc123",
    mimeType: "application/pdf"
  }
}
```

---

### 2.5 Fun√ß√£o Principal: `askGeminiFromDocs`

Esta fun√ß√£o **orquestra tudo**:

```typescript
export async function askGeminiFromDocs(pergunta: string): Promise<string> {
  // 1. Define qual modelo usar
  const model = process.env.GEMINI_MODEL || "gemini-2.5-flash";

  // 2. Monta prompt do sistema (instru√ß√µes para a IA)
  const systemPrompt = `
Voc√™ √© uma Consultora Especialista.
Responda exclusivamente com base nos documentos fornecidos.

FORMATO OBRIGAT√ìRIO DA RESPOSTA:
- Sempre use t√≠tulos, subt√≠tulos e listas numeradas ou com marcadores.
- Separe os t√≥picos com quebras de linha.
- Use **negrito** para destacar termos importantes.
- Organize a resposta para f√°cil leitura e compreens√£o.
- Caso a resposta seja um conjunto de etapas, utilize passo a passo numerado.
- Caso a resposta seja conceitual ou descritiva, utilize t√≥picos ou se√ß√µes.
- Nunca escreva tudo em um √∫nico par√°grafo.
- Caso n√£o haja informa√ß√£o clara nos documentos, responda exatamente:
  "N√£o encontrei essa informa√ß√£o em nossa base de dados."
`;

  // 3. Coleta e faz upload de todos os documentos (com cache!)
  const fileParts = await collectDocParts();

  // 4. Monta o array de contents (prompt + pergunta + arquivos)
  const contents: any[] = [
    systemPrompt,
    `Pergunta: ${pergunta}`,
    ...fileParts
  ];

  // 5. CHAMA GEMINI API
  const response = await ai.models.generateContent({
    model,
    contents,
  });

  // 6. Extrai texto da resposta
  const text = (response as any)?.text ?? "";

  return text || "";
}
```

#### Estrutura do `contents`

```typescript
[
  "Voc√™ √© uma Consultora...",           // System prompt (instru√ß√µes)
  "Pergunta: Como cadastrar usu√°rio?",  // Pergunta do usu√°rio
  { fileData: { fileUri: "...", mimeType: "..." } }, // Arquivo 1
  { fileData: { fileUri: "...", mimeType: "..." } }, // Arquivo 2
  { fileData: { fileUri: "...", mimeType: "..." } }, // Arquivo 3
  // ... outros arquivos
]
```

**Gemini processa tudo junto**: Ele l√™ os arquivos + a pergunta + as instru√ß√µes e gera uma resposta.

---

## üåê Componente 3: Rota (`routes/perguntar-gemini.ts`)

Esta √© a **API endpoint** que o frontend chama.

```typescript
import express from "express";
import { ensureThreadForAsk, loadThreads, saveThreads } from "../stores/threadsStore";
import { askGeminiFromDocs } from "../services/gemini";

const router = express.Router();

router.post("/perguntar-gemini", async (req, res) => {
  try {
    // 1. Extrai dados da requisi√ß√£o
    const pergunta = String(req.body.pergunta || "").trim();
    const wantedThreadId = (req.body.threadId as string) || null;

    // 2. Valida√ß√£o b√°sica
    if (!pergunta) {
      return res.status(400).json({ erro: "Pergunta vazia." });
    }

    // 3. Gerencia thread local (hist√≥rico de conversa)
    const t = await ensureThreadForAsk(wantedThreadId, "gemini");

    // 4. CHAMA GEMINI
    const texto = await askGeminiFromDocs(pergunta);

    // 5. Atualiza metadados da thread
    const threads = loadThreads();
    const i = threads.findIndex((x) => x.id === t.id);
    if (i >= 0) {
      // Atualiza t√≠tulo com primeira pergunta
      if (threads[i].title === "Novo chat") {
        threads[i].title = pergunta.slice(0, 60);
      }
      threads[i].updatedAt = Date.now();
      saveThreads(threads);
    }

    // 6. Retorna resposta
    res.json({ texto, threadId: t.id });

  } catch (e: any) {
    console.error("Erro /perguntar-gemini:", e);
    res.status(500).json({ erro: e?.message ?? "Erro inesperado." });
  }
});

export default router;
```

### Como o Frontend Chama

```typescript
// No React/Frontend
const response = await fetch('http://localhost:3000/perguntar-gemini', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    pergunta: "Como cadastrar usu√°rio?",
    threadId: "thread-abc-123" // Opcional, para continuar conversa
  })
});

const data = await response.json();
console.log(data.texto); // Resposta do Gemini
console.log(data.threadId); // ID da thread (para pr√≥xima pergunta)
```

---

## üóÇÔ∏è Componente 4: Thread Store (`stores/threadsStore.ts`)

### O que s√£o Threads?

**Thread** = Conversa completa (hist√≥rico de perguntas e respostas).

No exemplo, threads s√£o armazenadas **localmente** em `threads.json`:

```json
[
  {
    "id": "abc-123-def",
    "provider": "gemini",
    "assistant_id": "gemini",
    "thread_id": null,
    "title": "Como cadastrar usu√°rio?",
    "createdAt": 1697532000000,
    "updatedAt": 1697532180000
  },
  {
    "id": "xyz-789-uvw",
    "provider": "gemini",
    "assistant_id": "gemini",
    "thread_id": null,
    "title": "Pre√ßo das m√°quinas",
    "createdAt": 1697531000000,
    "updatedAt": 1697531300000
  }
]
```

### Fun√ß√£o `ensureThreadForAsk`

```typescript
export async function ensureThreadForAsk(
  wantedLocalThreadId: string | null,
  assistant_id: string
): Promise<ThreadRecord> {
  let threads = loadThreads();

  // 1. Se thread espec√≠fica foi pedida, retorna ela
  if (wantedLocalThreadId) {
    const existing = threads.find((t) => t.id === wantedLocalThreadId);
    if (existing) return existing;
  }

  // 2. Reutiliza thread mais recente do mesmo assistant
  const recent = threads.find((t) => t.assistant_id === assistant_id);
  if (recent) return recent;

  // 3. Cria nova thread
  const provider: Provider = "gemini";
  const thread_id = null; // Gemini n√£o usa thread_id remoto

  const newThread: ThreadRecord = {
    id: uuid(),
    provider,
    assistant_id,
    thread_id,
    title: "Novo chat",
    createdAt: Date.now(),
    updatedAt: Date.now(),
  };

  // 4. Salva no in√≠cio da lista (mais recente primeiro)
  threads.unshift(newThread);
  saveThreads(threads);

  return newThread;
}
```

**L√≥gica de Reuso**:
1. Se voc√™ passar `threadId` existente ‚Üí continua aquela conversa
2. Se n√£o passar ‚Üí reutiliza a mais recente do Gemini
3. Se n√£o houver nenhuma ‚Üí cria nova

---

## üì¶ Depend√™ncias (`package.json`)

### Principais Pacotes

```json
{
  "dependencies": {
    "@google/genai": "^1.13.0",    // ‚Üê SDK oficial do Gemini
    "express": "^5.1.0",            // Web server
    "cors": "^2.8.5",               // CORS para frontend
    "dotenv": "^17.2.1",            // Vari√°veis de ambiente
    "multer": "^2.0.2",             // Upload de arquivos
    "uuid": "^11.1.0"               // Gera√ß√£o de IDs √∫nicos
  }
}
```

### Script de Dev

```bash
npm run dev  # Usa tsx watch (hot reload)
```

---

## üîÑ Fluxo Completo: Da Pergunta √† Resposta

### Diagrama de Sequ√™ncia

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇFrontend ‚îÇ         ‚îÇ  Express ‚îÇ         ‚îÇ gemini.ts    ‚îÇ         ‚îÇ Gemini  ‚îÇ
‚îÇ (React) ‚îÇ         ‚îÇ  (Route) ‚îÇ         ‚îÇ (Service)    ‚îÇ         ‚îÇ   API   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ                   ‚îÇ                       ‚îÇ                      ‚îÇ
     ‚îÇ 1. POST           ‚îÇ                       ‚îÇ                      ‚îÇ
     ‚îÇ /perguntar-gemini ‚îÇ                       ‚îÇ                      ‚îÇ
     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                       ‚îÇ                      ‚îÇ
     ‚îÇ { pergunta }      ‚îÇ                       ‚îÇ                      ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ                      ‚îÇ
     ‚îÇ                   ‚îÇ 2. askGeminiFromDocs()‚îÇ                      ‚îÇ
     ‚îÇ                   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                      ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ                      ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ 3. Lista docs/       ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ‚îÄ‚îê                    ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ ‚îÇ                    ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ<‚îò                    ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ                      ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ 4. Para cada arquivo:‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ    - Calcula hash    ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ    - Verifica cache  ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ    - Upload (se novo)‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ                      ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ file.name, file.uri  ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ                      ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ 5. Monta contents:   ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ    [prompt, pergunta,‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ     file1, file2...] ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ                      ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ 6. generateContent() ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ                      ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ                      ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ    [IA PROCESSA]     ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ                      ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ response.text        ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ                      ‚îÇ
     ‚îÇ                   ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                      ‚îÇ
     ‚îÇ                   ‚îÇ texto da resposta     ‚îÇ                      ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ                      ‚îÇ
     ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                       ‚îÇ                      ‚îÇ
     ‚îÇ { texto, threadId}‚îÇ                       ‚îÇ                      ‚îÇ
     ‚îÇ                   ‚îÇ                       ‚îÇ                      ‚îÇ
```

### Tempo Estimado

1. **Primeira execu√ß√£o** (sem cache):
   - Upload de 3 PDFs: ~10-30 segundos (depende do tamanho)
   - Processamento Gemini: ~2-5 segundos
   - **Total**: ~15-35 segundos

2. **Execu√ß√µes seguintes** (com cache):
   - Cache hit: 0 segundos (n√£o reenvia)
   - Processamento Gemini: ~2-5 segundos
   - **Total**: ~2-5 segundos ‚ö°

---

## üí° Conceitos-Chave

### 1. Cache de Arquivos

**Problema**: Reenviar arquivos grandes √© lento e consome quota.  
**Solu√ß√£o**: Hash SHA256 + arquivo `.json` para mapear arquivos j√° enviados.

**Quando o cache √© invalidado?**
- Voc√™ modifica o conte√∫do do arquivo (hash muda)
- Voc√™ deleta `file_cache.json`
- O arquivo expira no Gemini (eles podem deletar ap√≥s X dias)

### 2. File API vs Embeddings

**Gemini File API** (usado aqui):
- ‚úÖ Voc√™ s√≥ faz upload
- ‚úÖ Gemini cuida da indexa√ß√£o/busca internamente
- ‚úÖ Mais simples de implementar
- ‚ùå Menos controle sobre a busca

**Embeddings + Vector Store** (alternativa):
- ‚úÖ Voc√™ tem controle total (pode usar pgvector, Pinecone, etc)
- ‚úÖ Busca sem√¢ntica customiz√°vel
- ‚ùå Mais complexo (precisa gerar embeddings, criar √≠ndice, etc)

### 3. System Prompt Engineering

```typescript
const systemPrompt = `
Voc√™ √© uma Consultora Especialista.
Responda exclusivamente com base nos documentos fornecidos.
...
`;
```

**Por que importante?**
- Instrui o modelo a **n√£o inventar** informa√ß√µes
- Define o **formato** da resposta (markdown, listas, etc)
- Estabelece o **tom** (formal, amig√°vel, t√©cnico)

**Dica**: Teste diferentes prompts para melhorar qualidade!

### 4. Gemini 2.5 Flash vs Pro

| Caracter√≠stica | Flash | Pro |
|----------------|-------|-----|
| **Velocidade** | ‚ö° Muito r√°pido (1-2s) | üê¢ Mais lento (3-5s) |
| **Qualidade** | ‚≠ê‚≠ê‚≠ê Boa | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excelente |
| **Custo** | $ Mais barato | $$ Mais caro |
| **Uso ideal** | Respostas r√°pidas, FAQs | An√°lises complexas |

**Recomenda√ß√£o para MVP**: Comece com **Flash**, depois teste Pro se precisar.

---

## üö® Problemas Comuns e Solu√ß√µes

### Erro: `INVALID_ARGUMENT`

```
Error: 400 INVALID_ARGUMENT: Request contains an invalid argument.
```

**Causas**:
1. API key inv√°lida ou expirada
2. Formato do `contents` incorreto
3. Arquivo n√£o foi processado (ainda em `PROCESSING`)

**Solu√ß√£o**:
```typescript
// Sempre aguarde processamento
while (getFile.state === "PROCESSING") {
  await new Promise((r) => setTimeout(r, 2000));
  getFile = await ai.files.get({ name: uploaded.name });
}
```

### Erro: `ValidationError`

```
ValidationError: File must be an object returned from upload
```

**Causa**: Voc√™ tentou passar um objeto manualmente constru√≠do em vez do retornado pelo upload.

**Solu√ß√£o**:
```typescript
// ‚úÖ CERTO
const uploaded = await ai.files.upload({ file: blob });
parts.push(createPartFromUri(uploaded.uri, uploaded.mimeType));

// ‚ùå ERRADO
parts.push({ name: "files/abc123" }); // Falta estrutura completa
```

### Erro: `Rate limit exceeded`

```
Error: 429 Resource has been exhausted
```

**Causa**: Ultrapassou limite gratuito (15 req/min para Flash).

**Solu√ß√£o**:
1. Adicionar retry com exponential backoff
2. Implementar fila de requisi√ß√µes
3. Fazer upgrade para tier pago

### Cache n√£o est√° funcionando

**Sintomas**: Arquivos sendo reenviados sempre.

**Checklist**:
- [ ] `file_cache.json` existe e tem permiss√£o de escrita?
- [ ] Hash est√° sendo calculado corretamente?
- [ ] Voc√™ est√° modificando o arquivo entre uploads?

---

## üéØ Adaptando para Seu Projeto Supabase

### Principais Diferen√ßas

| Caracter√≠stica | Backend Node.js | Supabase Edge Function |
|----------------|-----------------|------------------------|
| **Runtime** | Node.js | Deno |
| **File System** | ‚úÖ Acesso direto | ‚ùå Sem file system |
| **Cache** | Arquivo `.json` | Supabase Database |
| **Documentos** | Pasta `docs/` | Supabase Storage |

### Adapta√ß√£o 1: Armazenar Documentos

```typescript
// ‚ùå Backend Node.js
const files = fs.readdirSync('docs/');

// ‚úÖ Supabase Edge Function
const { data: files } = await supabase.storage
  .from('documentos')
  .list();
```

### Adapta√ß√£o 2: Cache de Arquivos

```typescript
// ‚ùå Backend Node.js
fs.writeFileSync('file_cache.json', JSON.stringify(cache));

// ‚úÖ Supabase Edge Function
await supabase
  .from('file_cache')
  .upsert({ hash, name, uri, mime_type });
```

### Adapta√ß√£o 3: Threads/Hist√≥rico

```typescript
// ‚ùå Backend Node.js
fs.writeFileSync('threads.json', JSON.stringify(threads));

// ‚úÖ Supabase Edge Function
// J√° est√° implementado! Tabela 'conversations' + 'messages'
```

---

## üìö Refer√™ncias e Recursos

### Documenta√ß√£o Oficial
- [Google Gemini API Docs](https://ai.google.dev/docs)
- [Gemini File API](https://ai.google.dev/docs/file_api)
- [SDK @google/genai](https://github.com/google/generative-ai-js)

### Modelos Dispon√≠veis
- `gemini-2.5-flash` - R√°pido e eficiente
- `gemini-2.5-pro` - M√°xima qualidade
- `gemini-1.5-flash` - Vers√£o anterior (ainda boa)
- `gemini-1.5-pro` - Vers√£o anterior Pro

### Limites Gratuitos (Free Tier)
- **Gemini Flash**: 15 requisi√ß√µes/minuto
- **Gemini Pro**: 2 requisi√ß√µes/minuto
- **File API**: 20GB storage, 1500 uploads/dia
- **Tamanho m√°x arquivo**: 2GB

---

## ‚úÖ Checklist de Implementa√ß√£o

Para implementar no seu projeto:

- [ ] Instalar SDK: `npm install @google/genai`
- [ ] Obter API key em https://makersuite.google.com/app/apikey
- [ ] Configurar `.env` com `GEMINI_API_KEY`
- [ ] Criar pasta `docs/` ou usar Supabase Storage
- [ ] Implementar fun√ß√£o de upload com cache
- [ ] Implementar fun√ß√£o de hash SHA256
- [ ] Criar sistema de cache (arquivo ou banco)
- [ ] Implementar `askGeminiFromDocs()` ou similar
- [ ] Criar rota/Edge Function para perguntas
- [ ] Testar com arquivo pequeno (TXT)
- [ ] Testar com PDF grande
- [ ] Implementar tratamento de erros
- [ ] Adicionar retry logic para rate limits
- [ ] Documentar prompts do sistema
- [ ] Testar qualidade das respostas

---

**√öltima atualiza√ß√£o**: Outubro 2025  
**Baseado em**: `agrosinergia_responde_backend` v1.0.0  
**SDK Gemini**: `@google/genai` v1.13.0
